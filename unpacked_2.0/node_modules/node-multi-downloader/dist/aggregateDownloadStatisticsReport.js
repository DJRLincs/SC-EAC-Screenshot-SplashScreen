"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatedDownloadStatisticsReportStream = void 0;
const stream_1 = require("stream");
const downloadStatisticsStream_1 = require("./downloadStatisticsStream");
const DEFAULT_MAX_LISTENER = 512;
class AggregatedDownloadStatisticsReportStream extends stream_1.Duplex {
    done;
    tick;
    maxListener;
    streamsByKey;
    fileSize;
    alreadyDownloaded;
    writing;
    constructor(options, maxListener = DEFAULT_MAX_LISTENER) {
        super({ ...options, objectMode: true });
        this.maxListener = maxListener;
        this.done = false;
        this.tick = null;
        this.streamsByKey = new Map();
        this.fileSize = options.fileSize;
        this.alreadyDownloaded = options.alreadyDownloaded;
        this.setMaxListeners(this.maxListener);
        this.writing = false;
    }
    calcAggregatedRate() {
        if (this.done) {
            return;
        }
        let downloaded = 0;
        let rate = 0;
        for (const stream of this.streamsByKey.values()) {
            downloaded += stream.downloaded;
            rate += stream.rate;
        }
        const results = {
            total: this.fileSize,
            alreadyDownloaded: this.alreadyDownloaded,
            downloaded,
            rate,
        };
        if (results.rate > 0) {
            this.push(results);
        }
        this.tick = setTimeout(() => this.calcAggregatedRate(), downloadStatisticsStream_1.TIMEOUT_DURATION / 2);
    }
    clearTickTimeout = () => {
        if (this.tick) {
            clearTimeout(this.tick);
            this.tick = null;
        }
    };
    _read = () => {
        if (!this.tick) {
            this.calcAggregatedRate();
        }
    };
    _write = (chunk, encoding, callback) => {
        if (this.writable && !this.writableEnded) {
            const { total, downloaded, rate, key } = chunk;
            this.streamsByKey.set(key, {
                total,
                downloaded,
                rate,
            });
            callback();
        }
    };
    stop = () => {
        this.done = true;
        this.clearTickTimeout();
    };
    _final = (callback) => {
        this.clearTickTimeout();
        callback();
    };
    _destroy = (error, callback) => {
        this.clearTickTimeout();
        callback(error);
    };
}
exports.AggregatedDownloadStatisticsReportStream = AggregatedDownloadStatisticsReportStream;
//# sourceMappingURL=aggregateDownloadStatisticsReport.js.map