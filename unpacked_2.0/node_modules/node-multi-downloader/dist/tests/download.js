"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialDownload = void 0;
/* eslint-disable no-console */
// Sample download function used in the Launcher
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const stream_1 = require("stream");
const mdFile_1 = require("../mdFile");
const remote_1 = require("../remote");
const initialDownload = async (url, verificationFileURL, destinationDirectory, progressCallback, chunkSize = 20 * 1024 * 1024) => {
    const initialP4kName = 'Data.p4k.part';
    const destinationP4kPath = path_1.default.join(destinationDirectory, initialP4kName);
    const finalP4kPath = path_1.default.join(destinationDirectory, 'Data.p4k');
    const isNewDownload = !fs_1.default.existsSync(destinationP4kPath);
    const onProgress = (stream) => stream.on('data', (info) => {
        const newInfo = {
            downloaded: info.alreadyDownloaded + info.downloaded,
            total: info.total,
        };
        progressCallback('installer@initial-download-progress', newInfo);
    });
    const retrieveInitialDownloadVerificationFile = async (verificationFileUrl) => {
        if (!verificationFileUrl) {
            return Promise.resolve(null);
        }
        try {
            const stream = await Promise.race([
                (0, remote_1.retrieveContent)(verificationFileUrl),
                new Promise((_, reject) => 
                // eslint-disable-next-line no-promise-executor-return
                setTimeout(() => reject(new Error('Could not retrieve the verification file within 5 seconds')), 5000)),
            ]);
            const isReadable = (s) => stream instanceof stream_1.Readable;
            if (!isReadable(stream)) {
                return Promise.resolve(null);
            }
            return new Promise((resolve, reject) => {
                let result = '';
                stream.on('data', (buffer) => {
                    result += buffer.toString();
                });
                stream.on('end', () => resolve(JSON.parse(result.trim())));
                stream.on('error', () => reject(Error(result)));
            });
        }
        catch (error) {
            return Promise.resolve(null);
        }
    };
    const createInitialDownload = async (initialDownloadUrl, hashUrl, destination) => {
        const verificationHeader = await retrieveInitialDownloadVerificationFile(hashUrl);
        const { size } = verificationHeader.file;
        if (verificationHeader && verificationHeader !== null) {
            console.log(`Verification header found for initial download: Filename: ${verificationHeader.file.name} FileSize: ${verificationHeader.file.size}`);
        }
        else {
            console.log('Verification header not found for initial download');
        }
        const defaultConfig = { chunkSize, noResize: true, concurrentDownloads: 1 };
        const config = { verificationHeader, ...defaultConfig };
        try {
            (0, child_process_1.execSync)(`FSUtil File CreateNew "${destination}" ${size}`);
            (0, child_process_1.execSync)(`FSUtil Sparse SetFlag "${destination}"`);
            (0, child_process_1.execSync)(`FSUtil Sparse SetRange "${destination}" 0 ${size}`);
        }
        catch (err) {
            if (fs_1.default.existsSync(destinationP4kPath)) {
                fs_1.default.unlinkSync(destinationP4kPath);
            }
            throw err;
        }
        return (0, mdFile_1.create)(destination, initialDownloadUrl, config);
    };
    progressCallback('installer@initial-download-start', {});
    const downloadOptions = {};
    if (!verificationFileURL) {
        return Promise.resolve(null);
    }
    const callDownload = isNewDownload
        ? createInitialDownload(url, verificationFileURL, destinationP4kPath)
        : (0, mdFile_1.open)(destinationP4kPath, { url });
    const file = await callDownload;
    try {
        await (0, mdFile_1.download)(file, onProgress, downloadOptions);
    }
    catch (error) {
        if (error.name === 'InvalidMDFileHeader') {
            console.log('Invalid MDFile Header, p4k is possibly complete but was not renamed properly');
            return null;
        }
        throw error;
    }
    finally {
        console.log({ finalP4kPath });
        await (0, mdFile_1.close)(file);
    }
    fs_1.default.renameSync(destinationP4kPath, finalP4kPath);
    console.log('************************INITIAL DOWNLOAD DONE');
    progressCallback('installer@initial-download-end', {});
    return undefined;
};
exports.initialDownload = initialDownload;
//# sourceMappingURL=download.js.map