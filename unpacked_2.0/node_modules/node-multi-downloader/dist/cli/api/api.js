"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSessionExpired = exports.endpoints = void 0;
/* eslint-disable no-underscore-dangle */
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const errors_1 = require("./errors");
const utils_1 = require("../utils");
exports.endpoints = {
    ACCOUNT_CHECK: '/account/check',
    ACCOUNT_CLAIMS: '/account/claims',
    AGREEMENTS_ACCEPT: '/agreements/accept',
    AGREEMENTS_GET: '/agreements/get',
    CONTENT_NEWS: '/content/news',
    CONTENT_PATCHNOTES: '/content/patchnotes',
    GAMES_CLAIMS: '/games/claims',
    GAMES_LIBRARY: '/games/library',
    GAMES_RELEASE: '/games/release',
    GAMES_TOKEN: '/games/token',
    SIGN_IN_CAPTCHA: '/signin/captcha',
    SIGN_IN_CLAIMS: '/signin/claims',
    SIGN_IN_MULTISTEP: '/signin/multiStep',
    SIGN_IN: '/signin',
    SIGN_OUT: '/signout',
    WARNINGS_GET: '/warnings/get',
    WARNINGS: '/warnings',
};
const isSessionExpired = (session) => !!(session.expires && Date.now() > session.expires);
exports.isSessionExpired = isSessionExpired;
class API {
    static instance;
    url;
    _session;
    _device;
    _endpoints;
    constructor(url = utils_1.API_URL) {
        this.url = url;
        this._session = null;
        this._device = null;
        this._endpoints = exports.endpoints;
        this.init();
    }
    init() {
        try {
            if (fs_1.default.existsSync(utils_1.STORAGE_FILE)) {
                const storage = fs_1.default.readFileSync(utils_1.STORAGE_FILE);
                const { device } = JSON.parse(storage.toString());
                this.device = device;
            }
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.error(err);
        }
    }
    static getInstance() {
        if (!API.instance) {
            API.instance = new API();
        }
        return API.instance;
    }
    set session(sessionState) {
        this._session = sessionState;
    }
    get session() {
        return this._session;
    }
    set device(deviceState) {
        this._device = deviceState;
    }
    get device() {
        return this._device;
    }
    get endpoints() {
        return this._endpoints;
    }
    async fetch({ endpoint, payload = {}, session = this._session, device = this._device, options = {}, }) {
        const url = `${this.url}${endpoint}`;
        let headers = {
            'Content-Type': 'application/json',
        };
        if (session) {
            headers = {
                ...headers,
                [session.key]: session.value,
            };
        }
        if (device) {
            headers = {
                ...headers,
                [device.key]: device.value,
            };
        }
        const ReqOptions = {
            method: 'POST',
            body: JSON.stringify(payload),
            headers,
            ...options,
        };
        try {
            const response = await (0, node_fetch_1.default)(url, ReqOptions);
            return response;
        }
        catch (err) {
            throw new errors_1.RsiConnectivityError('Could not connect to server', err);
        }
    }
    async call({ endpoint, payload, session = this._session, device = this._device, options, }) {
        try {
            const expired = session && (0, exports.isSessionExpired)(session);
            const response = await this.fetch({ endpoint, payload, session, device, options });
            if (expired || response.status === 403 || response.status === 401) {
                this.session = null;
                throw new errors_1.RsiAuthExpired('Your session has expired.  Please confirm your password again.', response);
            }
            const result = (await response.json());
            if (result.code === errors_1.Code.DEPRECATED_API) {
                throw new errors_1.RsiApiError('Launcher update required.', errors_1.Code.DEPRECATED_API, result);
            }
            if (result.success) {
                return result;
            }
            throw (0, errors_1.rsiApiErrorFactory)(result);
        }
        catch (err) {
            throw err instanceof Error ? err : new Error(`'Could not connect to server': ${err}`);
        }
    }
    async callImage({ endpoint, payload, session = this._session, device = this._device, options, }) {
        const response = await this.fetch({ endpoint, payload, session, device, options });
        const buffer = await response.arrayBuffer();
        const uint8Array = new Uint8Array(buffer);
        const img = Buffer.from(uint8Array).toString('base64');
        return img;
    }
}
exports.default = API;
//# sourceMappingURL=api.js.map