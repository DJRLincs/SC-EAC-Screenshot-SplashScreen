#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-console */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const bytes_1 = __importDefault(require("bytes"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const opener_1 = __importDefault(require("opener"));
const ora_1 = __importDefault(require("ora"));
const api_1 = __importDefault(require("./api"));
const errors_1 = require("./api/errors");
const captcha_1 = __importDefault(require("./prompts/captcha"));
const channels_1 = __importStar(require("./prompts/channels"));
const credentials_1 = __importDefault(require("./prompts/credentials"));
const games_1 = __importDefault(require("./prompts/games"));
const installerBasePack_1 = __importDefault(require("./prompts/installerBasePack"));
const mfa_1 = __importDefault(require("./prompts/mfa"));
const initialDownload_1 = __importDefault(require("./services/initialDownload"));
const utils_1 = require("./utils");
const __1 = __importDefault(require(".."));
process.title = 'RSI Launcher Downloader';
const initalStatistics = {
    gameId: '',
    channelId: '',
    isInitialDownload: true,
    startTime: 0,
    endTime: null,
    lastPeriodTime: Date.now(),
    lastPeriodSize: Date.now(),
    lastSpeed: 0,
    done: false,
    manifest: {
        size: null,
    },
    looseFiles: {
        size: null,
        files: null,
    },
    objectFiles: {
        size: null,
        files: null,
    },
};
class LauncherDownloader {
    rsiApi;
    claims;
    gameID;
    gameName;
    channelID;
    release;
    spinner;
    rootPath;
    installer = null;
    progressBar = null;
    statistics;
    progression = 0.01;
    cancel = null;
    constructor(api) {
        this.rsiApi = api;
        this.claims = null;
        this.gameID = null;
        this.gameName = '';
        this.channelID = null;
        this.release = null;
        this.rootPath = utils_1.TMP_DIR;
        this.spinner = (0, ora_1.default)({ stream: process.stdout, discardStdin: false });
        this.statistics = initalStatistics;
        if (!fs_1.default.existsSync(this.rootPath)) {
            fs_1.default.mkdirSync(this.rootPath);
        }
        this.progressBar = new cli_progress_1.default.SingleBar({
            format: `{phase} |{bar}| {percentage}% || Speed: {speed} || {filesDone}/{filesTotal} Files`,
            hideCursor: false,
            stopOnComplete: true,
            gracefulExit: true,
            emptyOnZero: true,
        });
    }
    async start() {
        await this.askCredentials();
        await this.askForChannel();
        await this.downloadActionListenner();
        await this.download();
    }
    async askCredentials() {
        const { username, password } = await (0, credentials_1.default)();
        try {
            this.spinner.start('Authenticating...');
            await this.rsiApi.authentication.signIn({ username, password }).finally(() => this.spinner.succeed());
        }
        catch (error) {
            if (error instanceof errors_1.RsiCaptchaRequiredError) {
                await this.askCaptcha({ username, password });
            }
            if (error instanceof errors_1.RsiMfaRequiredError) {
                await this.askMFA();
            }
            if (error instanceof errors_1.RsiMaxLoginAttemptError) {
                this.spinner.fail(`Authentication failed, ${error.message}.`);
                process.exit(0);
            }
            if (error instanceof errors_1.RsiAuthenticationError) {
                await this.askCredentials();
            }
        }
    }
    async askCaptcha({ username, password }) {
        try {
            const captchaImage = await api_1.default.authentication.captcha();
            await (0, utils_1.injectCaptchaToHTMLTemplate)(captchaImage);
            (0, opener_1.default)(path_1.default.resolve(utils_1.TMP_DIR, 'captcha.html'));
            const { captcha } = await (0, captcha_1.default)();
            this.spinner.start('Checking captcha...');
            await api_1.default.authentication.signIn({ username, password, captcha }).finally(() => this.spinner.succeed());
        }
        catch (error) {
            if (error instanceof errors_1.RsiCaptchaInvalidError) {
                this.spinner.fail('Captcha invalid, please retry.');
                await this.askCaptcha({ username, password });
            }
            if (error instanceof errors_1.RsiMfaRequiredError) {
                await this.askMFA();
            }
            if (error instanceof errors_1.RsiMaxLoginAttemptError) {
                this.spinner.fail(`Authentication failed, ${error.message}.`);
                process.exit(0);
            }
            if (error instanceof errors_1.RsiAuthWrongCredentialsError) {
                this.spinner.fail('Authentication failed, please retry.');
                await this.askCredentials();
            }
        }
    }
    async askMFA() {
        try {
            const { codeMfa, duration, deviceName } = await (0, mfa_1.default)();
            // if it's longer than session we need to store the deviceID in tmp
            if (duration !== 'session') {
                fs_1.default.writeFileSync(utils_1.STORAGE_FILE, JSON.stringify({ device: api_1.default.api.device }));
            }
            this.spinner.start('Checking MFA...');
            await api_1.default.authentication.signInMfa({ codeMfa, deviceName, duration });
            this.spinner.succeed();
        }
        catch (error) {
            if (error instanceof errors_1.RsiMfaCodeInvalidError) {
                this.spinner.fail('MFA code invalid, please retry.');
                await this.askMFA();
            }
        }
    }
    async getClaims() {
        if (this.claims) {
            return this.claims;
        }
        this.spinner.start('Getting claims...');
        const claims = await this.rsiApi.games.getClaims().finally(() => this.spinner.succeed());
        this.claims = claims;
        return claims;
    }
    async askForChannel() {
        const claims = await this.getClaims();
        this.spinner.start('Getting library...');
        const library = await this.rsiApi.games.getLibrary(claims).finally(() => this.spinner.succeed());
        const { gameID } = await (0, games_1.default)(library);
        this.gameID = gameID;
        try {
            const { channelID } = await (0, channels_1.default)(library, gameID);
            this.channelID = channelID;
            this.gameName = library.find((game) => game.id === gameID)?.name ?? '';
            this.spinner.start('Getting release...');
            const release = await this.rsiApi.games
                .getRelease({ claims, gameID, channelID, platformID: 'prod' })
                .finally(() => this.spinner.succeed());
            this.release = release;
        }
        catch (error) {
            if (error instanceof channels_1.PromptChannelNotFound) {
                this.spinner.fail(error.message);
                await this.askForChannel();
            }
        }
    }
    async download() {
        if (!this.release) {
            return;
        }
        const gameDirectory = path_1.default.resolve(this.rootPath, this.release.installDir);
        const channelDirectory = path_1.default.join(gameDirectory, this.release.channelId);
        console.log(`\nDownloading ${this.gameName} in ${channelDirectory} folder \n`);
        if (!fs_1.default.existsSync(channelDirectory)) {
            fs_1.default.mkdirSync(channelDirectory, { recursive: true });
        }
        const onProgress = (stream) => stream.on('data', (info) => {
            const filesTotal = info.filesTotal ?? 1;
            const valid = info.total > 0 && info.total < 100 * 1024 * 1024 * 1024 && filesTotal > 0;
            const downloaded = valid ? info.downloaded : 0;
            this.progression = (info.downloaded / info.total) * 100;
            if (valid) {
                const period = Date.now() - this.statistics.lastPeriodTime;
                if (period >= 1000) {
                    const periodDownloaded = downloaded - this.statistics.lastPeriodSize;
                    this.statistics.lastPeriodTime = Date.now();
                    this.statistics.lastPeriodSize = downloaded;
                    this.statistics.lastSpeed = (periodDownloaded * 1000) / period;
                }
            }
            this.progressBar?.update(this.progression, {
                speed: `${this.statistics.lastSpeed > 0 ? (0, bytes_1.default)(this.statistics.lastSpeed) : 0}/s`,
                phase: 'installer@initial-download-progress',
                filesDone: 0,
                filesTotal: 1,
            });
        });
        const initialP4kName = 'Data.p4k.part';
        const destinationP4kPath = path_1.default.join(channelDirectory, initialP4kName);
        const finalP4kPath = path_1.default.join(channelDirectory, 'Data.p4k');
        const isNewDownload = !fs_1.default.existsSync(destinationP4kPath);
        const p4kURL = new URL(`${this.release.p4kBase.url}?${this.release.p4kBase.signatures}`);
        const verificationFileURL = new URL(`${this.release.p4kBaseVerificationFile.url}?${this.release.p4kBaseVerificationFile.signatures}`);
        const initialDownload = new initialDownload_1.default(p4kURL, verificationFileURL, channelDirectory, onProgress);
        const download = isNewDownload
            ? await initialDownload.createInitialDownload()
            : await __1.default.open(destinationP4kPath, { url: p4kURL });
        this.statistics = {
            ...initalStatistics,
            lastPeriodTime: Date.now(),
            lastPeriodSize: Date.now(),
        };
        this.progressBar?.start(100, 0, {
            speed: 'N/A',
            phase: 'initializing',
        });
        // initialize the download with a rate limit of 100 bytes per second
        this.installer = this.installer ?? new __1.default(download, onProgress, { rateLimit: 100 });
        const [promise, _, signal] = !this.installer.downloadInstance ? this.installer.install() : this.installer.resume();
        try {
            // Fake setOptions action after 20s to set rateLimit to 0 (max speed)
            setTimeout(async () => {
                if (!this.installer) {
                    return;
                }
                console.log('\n --> Rate limit set to 0 (max speed) for 20s \n');
                this.installer.pause();
                this.installer.setOptions({ rateLimit: 0 });
                this.installer.resume();
            }, 20000);
            // Fake a pause action after 40s
            setTimeout(async () => {
                if (!this.installer) {
                    return;
                }
                console.log('\n --> Installer pause for 10s \n');
                this.installer.pause();
            }, 40000);
            // Fake resume action after 50s
            setTimeout(async () => {
                if (!this.installer) {
                    return;
                }
                console.log('\n --> Installer resume after 10s of pause \n');
                this.installer.resume();
            }, 50000);
            // Fake setOptions action after 55s to set rateLimit to 200
            setTimeout(async () => {
                if (!this.installer) {
                    return;
                }
                console.log('\n --> Rate limit set to 200 for 5 seconds \n');
                this.installer.pause();
                this.installer.setOptions({ rateLimit: 200 });
                this.installer.resume();
            }, 55000);
            // Fake setOptions action after 60s to set rateLimit to 0 (max speed)
            setTimeout(async () => {
                if (!this.installer) {
                    return;
                }
                console.log('\n --> Rate limit set to 0 (max speed) for the rest of the download \n');
                this.installer.pause();
                this.installer.setOptions({ rateLimit: 0 });
                this.installer.resume();
            }, 60000);
            await promise;
        }
        catch (error) {
            console.log(error);
        }
        finally {
            if (!signal.aborted) {
                this.progressBar?.stop();
                this.spinner.succeed('Download completed.');
                console.log(`\n --> Check ${this.gameName} in ${channelDirectory} folder \n`);
                fs_1.default.renameSync(destinationP4kPath, finalP4kPath);
                this.installer?.close();
                process.kill(process.pid);
            }
        }
    }
    downloadAction = async () => {
        this.spinner.start('\n Caught interrupt signal. Pausing download... \n');
        this.progressBar?.stop();
        this.installer?.pause();
        this.spinner.succeed('Download paused.');
        const { action } = await (0, installerBasePack_1.default)();
        switch (action) {
            case 'resume':
                this.spinner.start('Resuming download...');
                this.download();
                this.spinner.succeed('Download resumed.');
                break;
            default:
                this.spinner.succeed('Download stopped.');
                process.kill(process.pid);
        }
    };
    downloadActionListenner = async () => {
        process.on('SIGINT', async () => {
            await this.downloadAction();
        });
    };
}
const launcherDownloader = new LauncherDownloader(api_1.default);
launcherDownloader.start();
//# sourceMappingURL=index.js.map