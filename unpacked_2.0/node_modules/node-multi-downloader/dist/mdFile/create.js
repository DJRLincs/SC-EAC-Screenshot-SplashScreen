"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.generateChunks = void 0;
const constants_1 = require("./constants");
const mdFileInfo_1 = require("./mdFileInfo");
const types_1 = require("./types");
const Local = __importStar(require("../local"));
/**
 * Generate chunks for a file of a given size and chunk size
 *
 * @param fileSize - Size of the file in bytes
 * @param chunkSize - Size of each chunk in bytes
 * @returns - Array of chunks
 * @example - generateChunks(100, 10)
 */
function generateChunks(fileSize, chunkSize) {
    const numberOfChunks = Math.floor(fileSize / chunkSize) + 1;
    const lastChunkSize = Math.floor(fileSize % chunkSize);
    return Array.from({ length: numberOfChunks }, (_, i) => {
        // eslint-disable-next-line no-nested-ternary
        const size = i < numberOfChunks - 1 ? chunkSize : lastChunkSize === 0 ? chunkSize : lastChunkSize;
        const position = i * chunkSize;
        return {
            id: i,
            size,
            range: [position, position + size],
            downloaded: 0,
            status: types_1.ChunkStatus.Ready,
        };
    });
}
exports.generateChunks = generateChunks;
/**
 * Create a new MDFile instance and write MDFfileInfo
 *
 * @param path - Path to the file
 * @param url - URL of the file
 * @param options - Options for creating the file
 * @returns - MDFile instance
 * @example - create('path/to/file', new URL('https://example.com/file'), { concurrentDownloads: 8, chunkSize: 1024 * 1024 })
 */
async function create(path, url, options) {
    const { size } = options.verificationHeader.file;
    const resize = !options.noResize;
    const fileHandle = await Local.open(path, !resize ? 'r+' : 'w+');
    if (resize) {
        await Local.truncate(fileHandle, size);
    }
    const { concurrentDownloads = constants_1.DEFAULT_CONCURRENT_DOWNLOADS, chunkSize = constants_1.DEFAULT_CHUNK_SIZE, retries = constants_1.DEFAULT_RETRIES, rateLimit = constants_1.DEFAULT_RATE_LIMIT, meta = {}, verificationHeader, } = options;
    const actualChunkSize = verificationHeader ? verificationHeader.chunks.size : chunkSize;
    const header = {
        url: url.href,
        size,
        concurrentDownloads,
        rateLimit,
        chunkSize: actualChunkSize,
        retries,
        meta,
        verificationHeader,
    };
    const generatedChunks = generateChunks(size, actualChunkSize);
    const fileInfo = {
        header,
        chunks: generatedChunks,
    };
    const file = {
        ...fileInfo,
        fileHandle,
        finished: false,
        path,
    };
    await (0, mdFileInfo_1.writeMDFileInfo)(fileHandle, fileInfo, size);
    return file;
}
exports.create = create;
//# sourceMappingURL=create.js.map