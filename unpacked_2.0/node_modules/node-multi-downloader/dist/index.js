"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mdFile_1 = require("./mdFile");
const remote_1 = require("./remote");
class NodeMultiDowloader {
    downloadInstance = null;
    MDFile;
    progressCallback;
    isPaused;
    downloadOptions;
    /**
     * Create a NodeMultiDownloader instance
     * @param MDFIle - MDFile instance
     * @param progressCallback - Callback function to receive download progress // => (stream: AggregatedDownloadStatisticsReportStream) => void
     * @param downloadOptions - Options object // => { rateLimit: number }
     * @example - new NodeMultiDownloader(MDFile, progressCallback, { rateLimit: 1000000 }) // => NodeMultiDownloader instance
     */
    constructor(MDFIle, progressCallback, downloadOptions) {
        this.MDFile = MDFIle;
        this.progressCallback = progressCallback;
        this.downloadOptions = downloadOptions;
        this.isPaused = false;
    }
    /**
     * Set download options (rate limit) - pause the download if it's running and resume it after setting the options
     * @param options - Options object // => { rateLimit: number }
     * @returns - void
     * @example - setOptions({ rateLimit: 1000000 }) // => void
     */
    setOptions(options) {
        if (!this.downloadInstance) {
            throw new Error('downloadInstance is not defined');
        }
        this.downloadOptions = options;
    }
    /**
     * Resume a paused download
     * @returns - MDFile instance, stop function and AbortSignal
     * @example - resume() // => [MDFile instance, stop function, AbortSignal]
     */
    resume() {
        if (!this.isPaused) {
            throw new Error('Download is not paused');
        }
        this.isPaused = false;
        this.downloadInstance = this.install();
        return this.downloadInstance;
    }
    /**
     * Pause a running download
     */
    pause() {
        if (this.isPaused) {
            throw new Error('Download is already paused');
        }
        if (!this.downloadInstance) {
            throw new Error('downloadInstance is not defined');
        }
        const [_, cancel] = this.downloadInstance;
        this.isPaused = true;
        cancel();
    }
    /**
     * Initialize a download instance
     * @returns - MDFile instance, stop function and AbortSignal
     * @example - install() // => [MDFile instance, stop function, AbortSignal]
     */
    install() {
        this.downloadInstance = (0, mdFile_1.download)(this.MDFile, this.progressCallback, this.downloadOptions);
        return this.downloadInstance;
    }
    /**
     * Close the MDFile instance
     * @returns - Promise<void>
     * @example - close() // => Promise<void>
     */
    close() {
        return (0, mdFile_1.close)(this.MDFile);
    }
    /**
     * Create a MDFile instance
     * @param path - Path to the file
     * @param url - URL of the file
     * @param options - Options object // => { concurrentDownloads: number; chunkSize: number; retries?: number; bandwidthLimit?: number; meta?: Meta; verificationHeader: MDFileVerificationHeader; noResize?: boolean; }
     * @returns - MDFile instance
     * @example - NodeMultiDownloader.create(path, url, options) // => MDFile instance
     */
    static async create(path, url, options) {
        return (0, mdFile_1.create)(path, url, options);
    }
    /**
     * Open a file and create a MDFile instance
     * @param path - Path to the file
     * @param options - Options object // => { url: URL; concurrentDownloads: number; chunkSize: number; retries?: number; bandwidthLimit?: number; meta?: Meta; verificationHeader: MDFileVerificationHeader; noResize?: boolean; }
     * @returns - MDFile instance
     * @example - NodeMultiDownloader.open(path, options) // => MDFile instance
     */
    static async open(path, options) {
        return (0, mdFile_1.open)(path, options);
    }
    /**
     * Retrieve the content of a URL
     * @param url - URL of the file
     * @returns - Readable stream
     * @example - NodeMultiDownloader.retrieveContent(url) // => Readable stream
     */
    static async retrieveContent(url) {
        return (0, remote_1.retrieveContent)(url);
    }
}
exports.default = NodeMultiDowloader;
//# sourceMappingURL=index.js.map