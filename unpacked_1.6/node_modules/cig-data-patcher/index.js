/* eslint-disable no-underscore-dangle */
const CigDataPatcher = require('node-gyp-build')(__dirname);
const { Future } = require('fluture');
const patcherVersion = require('./package.json').config.changeList;
const { clearImmediate } = require('timers');

class InstallerError extends Error {
  constructor(message, bindingsError) {
    super(message);
    this.bindingsError = bindingsError;
  }
}

const install = (mode, installationPath, manifest, objectStore, options) => {
  if (!['verify', 'install'].includes(mode)) {
    throw new InstallerError("mode should be a either 'install' or 'verify'");
  }

  if (typeof installationPath !== 'string') {
    throw new InstallerError('installationPath should be a string');
  }

  if (typeof manifest !== 'object') {
    throw new InstallerError('manifest should be an object');
  }

  if (!('url' in manifest)) {
    throw new InstallerError('manifest.url should be specified');
  }

  if (typeof manifest.url !== 'string') {
    throw new InstallerError('manifest.url should be a string');
  }

  if ('suffix' in manifest && typeof manifest.suffix !== 'string') {
    throw new InstallerError('manifest.suffix should be a string');
  }

  if (typeof objectStore !== 'object') {
    throw new InstallerError('objectStore should be an object');
  }

  if (!('url' in objectStore)) {
    throw new InstallerError('objectStore.url should be specified');
  }

  if (typeof objectStore.url !== 'string') {
    throw new InstallerError('objectStore.url should be a string');
  }

  if ('suffix' in objectStore && typeof objectStore.suffix !== 'string') {
    throw new InstallerError('objectStore.suffix should be a string');
  }

  if (typeof options !== 'object') {
    throw new InstallerError('options should be an object');
  }

  const hasProgressCallback = 'progressCallback' in options;

  if (hasProgressCallback) {
    if (typeof options.progressCallback !== 'function') {
      throw new InstallerError('options.progressCallback should be a function');
    }
  }

  if ('concurrentTransfers' in objectStore && typeof objectStore.concurrentTransfers !== 'number') {
    throw new InstallerError('objectStore.concurrentTransfers should be a number');
  }

  if ('maximumDownloadBandwidth' in objectStore && typeof objectStore.maximumDownloadBandwidth !== 'number') {
    throw new InstallerError('objectStore.maximumDownloadBandwidth should be a number');
  }

  if ('maximumTransfersInFlight' in objectStore && typeof objectStore.maximumTransfersInFlight !== 'number') {
    throw new InstallerError('objectStore.maximumTransfersInFlight should be a number');
  }

  if ('retriesPerFile' in objectStore && typeof objectStore.retriesPerFile !== 'number') {
    throw new InstallerError('objectStore.retriesPerFile should be a number');
  }

  return Future((_, resolveInstaller) => {
    const installerInterface = {
      start() {
        return Future((reject, resolve) => {
          this._installer = new CigDataPatcher.Installer(
            mode,
            installationPath,
            manifest,
            objectStore,
            options,
            (error, result) => (error ? reject(new InstallerError(error.message, error)) : resolve(result)),
          );

          if (hasProgressCallback) {
            this._installer.setProgressCallback(options.progressCallback);
          }

          this._installer.start();

          return () => this._installer.cancel();
        });
      },
      pause() {
        this._installer.pause();
      },
      resume() {
        this._installer.resume();
      },
      setOption(name, value) {
        const validOptions = [
          'concurrentTransfers',
          'maximumDownloadBandwidth',
          'maximumTransfersInFlight',
          'retriesPerFile',
        ];

        if (validOptions.includes(name) && typeof value === 'number') {
          this._installer.setOption(name, value);
        }
      },
      state() {
        return this._installer.getState();
      },
      mode() {
        return this._installer.getMode();
      },
    };

    setImmediate(() => resolveInstaller(installerInterface));

    // No-op unsubscribe function
    return () => {};
  });
};

const createInstallationDirectory = (directoryPath) =>
  Future((reject, resolve) => {
    const immediateTask = setImmediate(() => {
      try {
        CigDataPatcher.CreateInstallationDirectory(directoryPath);
        resolve();
      } catch (e) {
        reject(new InstallerError(e.message, e));
      }
    });

    return () => {
      clearImmediate(immediateTask);
    };
  });

const createEmptySparseFile = (filePath, size) =>
  Future((reject, resolve) => {
    const immediateTask = setImmediate(() => {
      const result = CigDataPatcher.CreateEmptySparseFile(filePath, size);

      if (result.error) {
        reject(new Error(result.error_message));
      } else {
        resolve();
      }
    });

    return () => {
      clearImmediate(immediateTask);
    };
  });

module.exports = {
  InstallerError,
  install,
  createInstallationDirectory,
  createEmptySparseFile,
  patcherVersion,
};
