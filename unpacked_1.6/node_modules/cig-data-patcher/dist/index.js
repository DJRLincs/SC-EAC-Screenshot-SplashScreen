#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-console */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const bytes_1 = __importDefault(require("bytes"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const opener_1 = __importDefault(require("opener"));
const ora_1 = __importDefault(require("ora"));
const api_1 = __importDefault(require("./api"));
const errors_1 = require("./api/errors");
const captcha_1 = __importDefault(require("./prompts/captcha"));
const channels_1 = __importStar(require("./prompts/channels"));
const credentials_1 = __importDefault(require("./prompts/credentials"));
const games_1 = __importDefault(require("./prompts/games"));
const installerBasePack_1 = __importDefault(require("./prompts/installerBasePack"));
const mfa_1 = __importDefault(require("./prompts/mfa"));
const installer_1 = __importDefault(require("./services/installer"));
const utils_1 = require("./utils");
process.title = 'RSI Launcher Downloader';
class LauncherDownloader {
    constructor(api) {
        this.installer = null;
        this.progressBar = null;
        this.downloadAction = async () => {
            this.spinner.start('\n Caught interrupt signal. Pausing download... \n');
            this.progressBar?.stop();
            this.installer?.pause();
            this.spinner.succeed('Download paused.');
            const { action } = await (0, installerBasePack_1.default)();
            switch (action) {
                case 'resume':
                    this.spinner.start('Resuming download...');
                    this.download().then(() => this.spinner.succeed('Download resumed.'));
                    break;
                default:
                    this.spinner.succeed('Download stopped.');
                    process.kill(process.pid);
            }
        };
        this.downloadActionListenner = async () => {
            process.on('SIGINT', async () => {
                await this.downloadAction();
            });
        };
        this.rsiApi = api;
        this.claims = null;
        this.gameID = null;
        this.gameName = '';
        this.channelID = null;
        this.release = null;
        this.rootPath = utils_1.TMP_DIR;
        this.spinner = (0, ora_1.default)({ stream: process.stdout, discardStdin: false });
        if (!fs_1.default.existsSync(this.rootPath)) {
            fs_1.default.mkdirSync(this.rootPath);
        }
        this.progressBar = new cli_progress_1.default.SingleBar({
            format: `{phase} |{bar}| {percentage}% || Speed: {speed} || {filesDone}/{filesTotal} Files`,
            hideCursor: false,
            stopOnComplete: true,
            gracefulExit: true,
            emptyOnZero: true,
        });
    }
    async start() {
        await this.askCredentials();
        await this.askForChannel();
        await this.download();
        await this.downloadActionListenner();
    }
    async askCredentials() {
        const { username, password } = await (0, credentials_1.default)();
        try {
            this.spinner.start('Authenticating...');
            await this.rsiApi.authentication.signIn({ username, password }).finally(() => this.spinner.succeed());
        }
        catch (error) {
            if (error instanceof errors_1.RsiAuthenticationError) {
                await this.askCredentials();
            }
            if (error instanceof errors_1.RsiCaptchaRequiredError) {
                await this.askCaptcha({ username, password });
            }
            if (error instanceof errors_1.RsiMfaRequiredError) {
                await this.askMFA();
            }
            if (error instanceof errors_1.RsiMaxLoginAttemptError) {
                this.spinner.fail(`Authentication failed, ${error.message}.`);
                process.exit(0);
            }
        }
    }
    async askCaptcha({ username, password }) {
        try {
            const captchaImage = await api_1.default.authentication.captcha();
            await (0, utils_1.injectCaptchaToHTMLTemplate)(captchaImage);
            (0, opener_1.default)('./tmp/captcha.html');
            const { captcha } = await (0, captcha_1.default)();
            this.spinner.start('Checking captcha...');
            await api_1.default.authentication.signIn({ username, password, captcha }).finally(() => this.spinner.succeed());
        }
        catch (error) {
            if (error instanceof errors_1.RsiCaptchaInvalidError) {
                this.spinner.fail('Captcha invalid, please retry.');
                await this.askCaptcha({ username, password });
            }
            if (error instanceof errors_1.RsiMfaRequiredError) {
                await this.askMFA();
            }
            if (error instanceof errors_1.RsiAuthWrongCredentialsError) {
                this.spinner.fail('Authentication failed, please retry.');
                await this.askCredentials();
            }
            if (error instanceof errors_1.RsiMaxLoginAttemptError) {
                this.spinner.fail(`Authentication failed, ${error.message}.`);
                process.exit(0);
            }
        }
    }
    async askMFA() {
        try {
            const { codeMfa, duration, deviceName } = await (0, mfa_1.default)();
            // if it's longer than session we need to store the deviceID in tmp
            if (duration !== 'session') {
                fs_1.default.writeFileSync(path_1.default.join(this.rootPath, 'storage.json'), JSON.stringify({ device: api_1.default.api.device }));
            }
            this.spinner.start('Checking MFA...');
            await api_1.default.authentication.signInMfa({ codeMfa, deviceName, duration });
            this.spinner.succeed();
        }
        catch (error) {
            if (error instanceof errors_1.RsiMfaCodeInvalidError) {
                this.spinner.fail('MFA code invalid, please retry.');
                await this.askMFA();
            }
        }
    }
    async getClaims() {
        if (this.claims) {
            return this.claims;
        }
        this.spinner.start('Getting claims...');
        const claims = await this.rsiApi.games.getClaims().finally(() => this.spinner.succeed());
        this.claims = claims;
        return claims;
    }
    async askForChannel() {
        const claims = await this.getClaims();
        this.spinner.start('Getting library...');
        const library = await this.rsiApi.games.getLibrary(claims).finally(() => this.spinner.succeed());
        const { gameID } = await (0, games_1.default)(library);
        this.gameID = gameID;
        try {
            const { channelID } = await (0, channels_1.default)(library, gameID);
            this.channelID = channelID;
            this.gameName = library.find((game) => game.id === gameID)?.name ?? '';
            this.spinner.start('Getting release...');
            const release = await this.rsiApi.games
                .getRelease({ claims, gameID, channelID, platformID: 'prod' })
                .finally(() => this.spinner.succeed());
            this.release = release;
        }
        catch (error) {
            if (error instanceof channels_1.PromptChannelNotFound) {
                this.spinner.fail(error.message);
                await this.askForChannel();
            }
        }
    }
    async download() {
        if (!this.release) {
            return;
        }
        const gameDirectory = path_1.default.resolve(this.rootPath, this.release.installDir);
        const channelDirectory = path_1.default.join(gameDirectory, this.release.channelId);
        console.log(`\nDownloading ${this.gameName} in ${channelDirectory} folder \n`);
        const onProgress = (phase, info) => {
            this.progressBar?.update(info.progression, {
                speed: phase === 'installer@update-p4k-structure-start' ? 'N/A' : `${info.speed > 0 ? (0, bytes_1.default)(info.speed) : 0}/s`,
                phase,
                filesDone: phase === 'installer@update-p4k-structure-start' ? 'N/A' : info.filesDone ?? 0,
                filesTotal: phase === 'installer@update-p4k-structure-start' ? 'N/A' : info.filesTotal ?? 0,
            });
        };
        if (!this.installer) {
            this.installer = new installer_1.default({
                p4kBase: this.release.p4kBase,
                p4kBaseVerificationFile: this.release.p4kBaseVerificationFile,
                manifest: this.release.manifest,
                objectStore: this.release.objects,
                channelDirectory,
                onProgressCallback: onProgress,
                release: this.release,
                gameName: this.gameName,
                gameDirectory,
            });
            this.installer.on('download@done', () => {
                this.progressBar?.stop();
                this.spinner.succeed('Download completed.');
                console.log(`\n --> Check ${this.gameName} in ${channelDirectory} folder \n`);
                return process.kill(process.pid);
            });
            await this.installer.start();
        }
        else {
            this.installer?.resume();
        }
        this.progressBar?.start(100, 0, {
            speed: 'N/A',
            phase: 'initializing',
        });
    }
}
const launcherDownloader = new LauncherDownloader(api_1.default);
launcherDownloader.start();
//# sourceMappingURL=index.js.map