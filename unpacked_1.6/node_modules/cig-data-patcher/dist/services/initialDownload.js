"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-console */
const fs = __importStar(require("fs"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const fluture_1 = require("fluture");
// eslint-disable-next-line import/no-extraneous-dependencies
const MDFile_1 = require("node-multi-downloader/dist/MDFile");
// eslint-disable-next-line import/no-extraneous-dependencies
const Remote_1 = require("node-multi-downloader/dist/Remote");
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-var-requires
const cigDataPatcher = require('../..');
const { createEmptySparseFile } = cigDataPatcher;
const installerOptions = {};
class InitialDownload {
    constructor(url, verificationFileURL, destinationDirectory, progressCallback) {
        this.onProgress = (stream) => {
            return stream.on('data', (info) => {
                const newInfo = {
                    downloaded: info.alreadyDownloaded + info.downloaded,
                    total: info.total,
                };
                this.progressCallback('installer@initial-download-progress', newInfo);
            });
        };
        this.url = url;
        this.verificationFileURL = verificationFileURL;
        this.destinationDirectory = destinationDirectory;
        this.progressCallback = progressCallback;
        this.initialP4kName = 'Data.p4k.part';
        this.destinationP4kPath = path_1.default.join(this.destinationDirectory, this.initialP4kName);
        this.finalP4kPath = path_1.default.join(this.destinationDirectory, 'Data.p4k');
        this.chunkSize = 20 * 1024 * 1024;
        this.isNewDownload = !fs.existsSync(this.destinationP4kPath);
    }
    retrieveInitialDownloadVerificationFile() {
        if (!this.verificationFileURL) {
            return (0, fluture_1.resolve)(null);
        }
        return (0, fluture_1.race)((0, Remote_1.retrieveContent)(this.verificationFileURL))((0, fluture_1.rejectAfter)(5000)(new Error('Could not retrieve the verification file within 5 seconds')))
            .pipe((0, fluture_1.chain)((stream) => (0, fluture_1.Future)((rej, res) => {
            let result = '';
            stream.on('data', (buffer) => {
                result += buffer.toString();
            });
            stream.on('end', () => res(JSON.parse(result.trim())));
            stream.on('error', () => rej(Error(result)));
            // cancellation function
            return () => { };
        })))
            .pipe((0, fluture_1.chainRej)(() => (0, fluture_1.resolve)(null)));
    }
    createInitialDownload() {
        return (0, fluture_1.both)((0, Remote_1.retrieveContentLength)(this.url))(this.retrieveInitialDownloadVerificationFile()).pipe((0, fluture_1.chain)(([size, verificationHeader]) => {
            if (verificationHeader && verificationHeader !== null) {
                console.log(
                // eslint-disable-next-line max-len
                `Verification header found for initial download: Filename: ${verificationHeader.file.name} FileSize: ${verificationHeader.file.size}`);
            }
            else {
                console.log('Verification header not found for initial download');
            }
            const defaultConfig = { chunkSize: this.chunkSize, noResize: true, concurrentDownloads: 16 };
            const config = verificationHeader ? { verificationHeader, ...defaultConfig } : defaultConfig;
            return createEmptySparseFile(this.destinationP4kPath, size)
                .pipe((0, fluture_1.chainRej)((err) => {
                if (fs.existsSync(this.destinationP4kPath)) {
                    fs.unlinkSync(this.destinationP4kPath);
                }
                return (0, fluture_1.reject)(err);
            }))
                .pipe((0, fluture_1.chain)(() => (0, MDFile_1.create)(this.destinationP4kPath, this.url, config)));
        }));
    }
    start() {
        this.progressCallback('installer@initial-download-start', {});
        const downloadOptions = 'maximumDownloadBandwidth' in installerOptions ? { rateLimit: installerOptions.maximumDownloadBandwidth } : {};
        if (!this.verificationFileURL) {
            return (0, fluture_1.reject)(new Error('No verification file URL provided'));
        }
        const callDownload = this.isNewDownload
            ? this.createInitialDownload()
            : (0, MDFile_1.open)(this.destinationP4kPath, { url: this.url });
        return (0, fluture_1.hook)(callDownload)(MDFile_1.close)((file) => (0, MDFile_1.download)(file, this.onProgress, downloadOptions))
            .pipe((0, fluture_1.chainRej)((error) => {
            if (error.name === 'InvalidMDFileHeader') {
                console.log('Invalid MDFile Header, p4k is possibly complete but was not renamed properly');
                return (0, fluture_1.resolve)(null);
            }
            return (0, fluture_1.reject)(error);
        }))
            .pipe((0, fluture_1.chain)(() => (0, fluture_1.encaseP)(() => fs_1.promises.rename(this.destinationP4kPath, this.finalP4kPath))(this.finalP4kPath)))
            .pipe((0, fluture_1.chain)(() => {
            console.log('************************INITIAL DOWNLOAD DONE');
            this.progressCallback('installer@initial-download-end', {});
            return (0, fluture_1.resolve)(undefined);
        }));
    }
}
exports.default = InitialDownload;
//# sourceMappingURL=initialDownload.js.map