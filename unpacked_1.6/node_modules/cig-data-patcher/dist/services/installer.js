"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-console */
/* eslint-disable no-underscore-dangle */
const events_1 = __importDefault(require("events"));
const fs_1 = __importDefault(require("fs"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const fluture_1 = require("fluture");
const sudo_prompt_1 = require("sudo-prompt");
const ESU = __importStar(require("./eacSettingsUtilities"));
const IEWS = __importStar(require("./eacWindowsService"));
const initialDownload_1 = __importDefault(require("./initialDownload"));
const downloadPhase_1 = require("../utils/downloadPhase");
const execPromise = (0, util_1.promisify)(sudo_prompt_1.exec);
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-var-requires
const cigDataPatcher = require('../..');
const { install } = cigDataPatcher;
const initalStatistics = {
    gameId: '',
    channelId: '',
    isInitialDownload: true,
    startTime: 0,
    endTime: null,
    lastPeriodTime: Date.now(),
    lastPeriodSize: Date.now(),
    lastSpeed: 0,
    done: false,
    manifest: {
        size: null,
    },
    looseFiles: {
        size: null,
        files: null,
    },
    objectFiles: {
        size: null,
        files: null,
    },
};
class Installer extends events_1.default {
    constructor({ p4kBase, p4kBaseVerificationFile, manifest, objectStore, channelDirectory, onProgressCallback, release, gameName, gameDirectory, }) {
        super();
        this.isPaused = false;
        this.progression = 0.01;
        this.phase = 'initializing';
        this._runningInstaller = null;
        this.pausable = false;
        this.downloadProgressCallback = (phase, info) => {
            const singleFilePhases = ['installer@initial-download-progress', 'installer@retrieve-remote-file-list-progress'];
            if (this.isPaused) {
                return;
            }
            this.phase = phase;
            switch (this.phase) {
                case downloadPhase_1.PHASE.RETRIEVE_REMOTE_FILE_LIST_START:
                case downloadPhase_1.PHASE.RETRIEVE_REMOTE_FILE_LIST_PROGRESS:
                case downloadPhase_1.PHASE.RETRIEVE_REMOTE_FILE_LIST_END:
                case downloadPhase_1.PHASE.COMPUTE_FILE_LIST_DIFFERENCE_START:
                case downloadPhase_1.PHASE.COMPUTE_FILE_LIST_DIFFERENCE_END:
                case downloadPhase_1.PHASE.UPDATE_LOOSE_FILES_START:
                case downloadPhase_1.PHASE.UPDATE_LOOSE_FILES_END:
                case downloadPhase_1.PHASE.UPDATE_P4K_STRUCTURE_START:
                case downloadPhase_1.PHASE.UPDATE_P4K_STRUCTURE_END:
                case downloadPhase_1.PHASE.UPDATE_FILES_INSIDE_P4K_START:
                    this.pausable = false;
                    break;
                case downloadPhase_1.PHASE.INITIAL_DOWNLOAD_PROGRESS:
                    this.pausable = true;
                    break;
                case downloadPhase_1.PHASE.UPDATE_LOOSE_FILES_PROGRESS:
                    this.pausable = info.filesDone !== info.filesTotal;
                    break;
                case downloadPhase_1.PHASE.UPDATE_FILES_INSIDE_P4K_END:
                    this.pausable = false;
                    break;
                case downloadPhase_1.PHASE.UPDATE_FILES_INSIDE_P4K_PROGRESS:
                    this.pausable = info.filesDone !== info.filesTotal;
                    break;
                default:
            }
            if ([
                'installer@initial-download-start',
                'installer@update-files-inside-p4k-start',
                'installer@update-loose-files-start',
                'installer@retrieve-remote-file-list-start',
            ].includes(phase)) {
                this.progression = 0.01;
            }
            if ([
                'installer@initial-download-progress',
                'installer@update-files-inside-p4k-progress',
                'installer@update-loose-files-progress',
                'installer@retrieve-remote-file-list-progress',
                'installer@update-p4k-structure-start',
                'installer@update-p4k-structure-end',
            ].includes(phase)) {
                const filesTotal = singleFilePhases.includes(phase) ? 1 : info.filesTotal;
                const valid = info.total > 0 && info.total < 100 * 1024 * 1024 * 1024 && filesTotal > 0;
                const downloaded = valid ? info.downloaded : 0;
                const total = valid ? info.total : 0;
                this.progression = valid ? (downloaded / total) * 100 : 0;
                if (valid) {
                    const period = Date.now() - this.statistics.lastPeriodTime;
                    if (period >= this.sampleTime) {
                        const periodDownloaded = downloaded - this.statistics.lastPeriodSize;
                        this.statistics.lastPeriodTime = Date.now();
                        this.statistics.lastPeriodSize = downloaded;
                        this.statistics.lastSpeed = (periodDownloaded * 1000) / period;
                    }
                }
                if (phase === 'installer@retrieve-remote-file-list-progress' && info.total > 0) {
                    this.statistics.manifest.size = info.total;
                }
                if (phase === 'installer@update-loose-files-progress' && info.total > 0) {
                    this.statistics.looseFiles.size = info.total;
                    this.statistics.looseFiles.files = info.filesTotal;
                }
                if (phase === 'installer@update-files-inside-p4k-progress' && info.total > 0) {
                    this.statistics.objectFiles.size = info.total;
                    this.statistics.objectFiles.files = info.filesTotal;
                }
                if (phase === 'installer@initial-download-progress') {
                    this.progression = (info.downloaded / info.total) * 100;
                }
                if ([
                    'installer@initial-download-end',
                    'installer@update-files-inside-p4k-end',
                    'installer@update-loose-files-end',
                    'installer@retrieve-remote-file-list-end',
                ].includes(phase)) {
                    this.progression = 0.01;
                }
                this.onProgressCallback(phase, {
                    ...info,
                    speed: this.statistics.lastSpeed,
                    progression: this.progression,
                    filesTotal: singleFilePhases.includes(phase) ? 1 : info.filesTotal,
                });
            }
        };
        this.createDirectories = async (...directories) => {
            const installerSupportExecutable = path_1.default.resolve(__dirname, '../../cli/resources', 'installer-support.exe');
            const args = directories
                .filter((directory) => !fs_1.default.existsSync(directory))
                .map((directory) => `--create-installation-directory "${directory}"`);
            if (!args.length) {
                return false;
            }
            const cmd = `"${installerSupportExecutable}" ${args.join(' ')}`;
            try {
                await execPromise(cmd);
                return true;
            }
            catch (error) {
                console.error(`Error while attempting to create directories with command: ${cmd}, ${error}`);
                return false;
            }
        };
        this.installerTask = () => {
            return (this.isInitialDownload ? this.getInitialDownload() : this.getPatchInstallation())
                .pipe((0, fluture_1.chain)(() => {
                return (0, fluture_1.attemptP)(() => ESU.isAvailable(this.channelDirectory).then((available) => {
                    if (!available) {
                        console.log(`Anti Cheat files not available`);
                        return Promise.resolve();
                    }
                    return ESU.readSettings(this.channelDirectory).then((settings) => {
                        return IEWS.installWindowsService({
                            gameDirectory: this.channelDirectory,
                            gameName: this.gameName,
                            environment: this.release.channelId,
                            force: false,
                            productId: settings.productid,
                        });
                    });
                }));
            }))
                .pipe((0, fluture_1.fork)((error) => {
                console.log(`Error installing at ${this.channelDirectory}: ${error}`);
                this.runningInstaller = null;
            })(() => {
                if (this.isInitialDownload) {
                    console.log(`\n\nInitial pack installed (${this.release.gameId} ${this.release.channelId}) in ${this.channelDirectory} \n`);
                    return this.start();
                }
                console.log(`\n\nDelta update applied (${this.release.gameId} ${this.release.channelId}) in ${this.channelDirectory} \n`);
                this.emit('download@done', this.statistics);
                this.runningInstaller = null;
                if (this.statistics.manifest.size === null) {
                    this.statistics.manifest.size = 0;
                }
                if (this.statistics.looseFiles.size === null) {
                    this.statistics.looseFiles.size = 0;
                    this.statistics.looseFiles.files = 0;
                }
                if (this.statistics.objectFiles.size === null) {
                    this.statistics.objectFiles.size = 0;
                    this.statistics.objectFiles.files = 0;
                }
                this.statistics.endTime = Date.now();
                this.statistics.done = true;
                return this.statistics;
            }));
        };
        this.start = async () => {
            this.isInitialDownload = !!this.p4kBaseUrl && !fs_1.default.existsSync(`${this.channelDirectory}/Data.p4k`);
            if (!fs_1.default.existsSync(this.channelDirectory)) {
                console.log(`Creating directory ${this.channelDirectory}`);
                await this.createDirectories(this.gameDirectory, this.channelDirectory);
            }
            this.statistics = {
                ...initalStatistics,
                lastPeriodTime: Date.now(),
                lastPeriodSize: Date.now(),
            };
            this._runningInstaller = {
                type: this.isInitialDownload ? 'initial' : 'patch',
                task: this.installerTask,
                execution: this.installerTask(),
                controls: null,
            };
            return this._runningInstaller;
        };
        this.pause = () => {
            if (this._runningInstaller && !this.isPaused) {
                this.isPaused = true;
                if (this.runningInstaller?.type === 'initial' && typeof this._runningInstaller.execution === 'function') {
                    this._runningInstaller.execution();
                }
                else {
                    this._runningInstaller.controls?.pause();
                }
            }
        };
        this.resume = () => {
            if (this._runningInstaller) {
                if (this.statistics) {
                    this.statistics.lastPeriodTime = Date.now();
                }
                this.isPaused = false;
                if (this.runningInstaller?.type === 'initial') {
                    this._runningInstaller.execution = this._runningInstaller.task();
                }
                else {
                    this._runningInstaller.controls?.resume();
                }
            }
        };
        this.cancel = () => {
            if (this._runningInstaller && typeof this._runningInstaller.execution === 'function') {
                this._runningInstaller.execution();
            }
        };
        this.statistics = initalStatistics;
        this.sampleTime = 1000;
        this.p4kBaseUrl = new URL(`${p4kBase.url}?${p4kBase.signatures}`);
        this.p4kBaseVerificationFileUrl = new URL(`${p4kBaseVerificationFile.url}?${p4kBaseVerificationFile.signatures}`);
        this.manifest = { url: manifest.url, suffix: `?${manifest.signatures}` };
        this.objectStore = { url: objectStore.url, suffix: `?${objectStore.signatures}` };
        this.channelDirectory = channelDirectory;
        this.onProgressCallback = onProgressCallback;
        this.release = release;
        this.gameName = gameName;
        this.gameDirectory = gameDirectory;
        this.initialDownload = new initialDownload_1.default(this.p4kBaseUrl, this.p4kBaseVerificationFileUrl, this.channelDirectory, this.downloadProgressCallback);
        this.isInitialDownload = !!this.p4kBaseUrl && !fs_1.default.existsSync(`${this.channelDirectory}/Data.p4k`);
    }
    get runningInstaller() {
        return this._runningInstaller;
    }
    set runningInstaller(runningInstaller) {
        this._runningInstaller = runningInstaller;
    }
    getPatchInstallation() {
        return install('install', this.channelDirectory, { url: this.manifest.url, suffix: this.manifest.suffix }, { url: this.objectStore.url, suffix: this.objectStore.suffix }, { progressCallback: this.downloadProgressCallback }).pipe((0, fluture_1.chain)((installer) => {
            console.log('\n\n************************PATCHING DOWNLOAD START\n');
            const easyAntiCheatDirectory = path_1.default.resolve(this.channelDirectory, 'EasyAntiCheat');
            // Delete easy anti cheat folder if it exist
            promises_1.default
                .rm(easyAntiCheatDirectory, { recursive: true, force: true })
                .then(() => {
                console.log('\n************************EAC DIRECTORY SUCCESSFULLY DELETED\n');
            })
                .catch((error) => {
                console.log('\n************************EAC DIRECTORY FAILED TO DELETE\n', error);
            });
            if (this._runningInstaller) {
                this._runningInstaller.controls = installer;
            }
            return installer.start();
        }));
    }
    getInitialDownload() {
        return this.initialDownload.start();
    }
}
exports.default = Installer;
//# sourceMappingURL=installer.js.map